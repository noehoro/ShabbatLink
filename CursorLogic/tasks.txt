ShabbatLink Implementation Tasks
=================================

Version: 1.0 (Pilot)
Based on: prd.txt v1.1

================================================================================
PHASE 1: PROJECT SETUP
================================================================================

[ ] 1.1 Initialize Project Structure
    [ ] Create root directory structure:
        /backend (Flask API)
        /frontend (Next.js)
    [ ] Initialize Git repository (if not already done)
    [ ] Create .gitignore for Python, Node, and environment files

[ ] 1.2 Backend Setup
    [ ] Create Python virtual environment
    [ ] Create requirements.txt with dependencies:
        - Flask
        - Flask-CORS
        - Flask-SQLAlchemy
        - psycopg2-binary
        - python-dotenv
        - gunicorn
    [ ] Create backend/.env.example with required variables:
        - DATABASE_URL
        - ADMIN_PASSWORD
        - SECRET_KEY
        - FRONTEND_URL
    [ ] Create basic Flask app structure:
        - app/__init__.py (app factory)
        - app/config.py (configuration)
        - app/models/ (database models)
        - app/routes/ (API endpoints)
        - app/services/ (business logic)
        - run.py (entry point)

[ ] 1.3 Frontend Setup
    [ ] Initialize Next.js project with TypeScript
    [ ] Create frontend/.env.example:
        - NEXT_PUBLIC_API_URL
    [ ] Set up project structure:
        - app/ (Next.js app router)
        - components/ (reusable components)
        - lib/ (utilities, API client)
        - styles/ (global styles, variables, mixins)

[ ] 1.4 Design System Setup (CSS Modules)
    [ ] Create global CSS variables file (styles/variables.css):
        --color-primary: #7ECEC5 (teal)
        --color-accent: #8B7355 (bronze)
        --color-background: #FDF9F3 (cream)
        --color-primary-dark: #5BA39A (deep teal)
        --color-highlight: #D4A84B (soft gold)
        --color-text: #2D3436 (charcoal)
        --color-gray: #F5F5F5 (light gray)
        --font-heading: 'Playfair Display', serif
        --font-body: 'DM Sans', sans-serif
        --spacing-xs, --spacing-sm, --spacing-md, --spacing-lg, --spacing-xl
        --radius-sm, --radius-md, --radius-lg
        --shadow-sm, --shadow-md, --shadow-lg
    [ ] Create global reset/base styles (styles/globals.css)
    [ ] Add custom fonts (Playfair Display + DM Sans) via next/font or Google Fonts
    [ ] Create shared utility classes file (styles/utilities.css) for common patterns
    [ ] Establish CSS Module naming convention:
        - Component styles: ComponentName.module.css
        - Co-located with component files
        - Use camelCase for class names

================================================================================
PHASE 2: DATABASE & MODELS
================================================================================

[ ] 2.1 Database Schema Design
    [ ] Design ERD for all entities
    [ ] Document relationships and constraints

[ ] 2.2 Create SQLAlchemy Models
    [ ] Guest model:
        - id (UUID, primary key)
        - full_name
        - email (unique)
        - phone
        - party_size
        - neighborhood (enum)
        - max_travel_time (enum: 15, 30, 45, 60)
        - languages (ARRAY type in Postgres: English, Spanish, Portuguese)
            *** Array type adds complexity but fine for pilot ***
            *** Matching engine receives plain list, easy overlap check ***
        - kosher_requirement (enum)
        - contribution_range (enum)
        - vibe_chabad (1-5)
        - vibe_social (1-5)
        - vibe_formality (1-5)
        - notes_to_admin (text, nullable)
        - no_show_acknowledged (boolean)
        - no_show_count (integer, default 0)
        - is_flagged (boolean, default false)
        - created_at
        - updated_at

    [ ] Host model:
        - id (UUID, primary key)
        - full_name
        - email (unique)
        - phone
        - neighborhood (enum)
        - address (text, hidden until match accepted)
        - seats_available
        - languages (array)
        - kosher_level (enum)
        - contribution_preference (enum)
        - vibe_chabad (1-5)
        - vibe_social (1-5)
        - vibe_formality (1-5)
        - tagline (text, nullable)
        - private_notes (text, nullable)
        - no_show_acknowledged (boolean)
        - created_at
        - updated_at

    [ ] Match model:
        - id (UUID, primary key)
        - guest_id (foreign key)
        - host_id (foreign key)
        - status (enum: proposed, requested, accepted, declined, confirmed)
            *** 5 STATES ONLY - no "sent" or "cancelled" ***
        - match_score (float)
        - why_its_a_fit (text)
        - admin_notes (text, nullable)
        - requested_at (timestamp, nullable) -- when sent to host
        - responded_at (timestamp, nullable) -- when host accepted/declined
        - finalized_at (timestamp, nullable) -- when admin confirmed
        - guest_confirmed_at (timestamp, nullable) -- when guest confirmed attendance (day-of)
        - guest_no_show (boolean, default false) -- host reported no-show
        - no_show_reported_at (timestamp, nullable) -- when host reported
        - created_at
        - updated_at
        
        *** NOTE: Attendance confirmation and no-show tracking are PER MATCH ***
        *** Not on Guest model, because they're event-specific ***

    [ ] MagicLink model (for PROFILE EDITING only):
        - id (UUID, primary key)
        - email
        - token (unique)
        - user_type (enum: guest, host)
        - user_id (UUID)
        - expires_at (15 min)
        - used_at (nullable)
        - created_at
        *** NOTE: This is NOT used for match accept/decline ***

    [ ] MatchActionToken model (for ONE-CLICK match responses):
        - No database storage needed - use signed tokens
        - Token encodes: match_id + action + expires_at + signature
        - Signature uses SECRET_KEY via HMAC
        - Verified on request, not stored

    [ ] Email model (for simulated emails):
        - id (UUID, primary key)
        - to_email
        - to_name
        - email_type (enum)
        - subject
        - body
        - status (enum: queued, sent, failed)
        - sent_at (nullable)
        - created_at

    [ ] ActivityLog model:
        - id (UUID, primary key)
        - action_type (enum)
        - actor (admin or system)
        - target_type (guest, host, match)
        - target_id (UUID)
        - details (JSON)
        - created_at

[ ] 2.3 Create Database Migrations
    [ ] Set up Flask-Migrate
    [ ] Create initial migration
    [ ] Test migration up/down

[ ] 2.4 Seed Data (for development)
    [ ] Create seed script with sample guests
    [ ] Create seed script with sample hosts
    [ ] Create neighborhood distance matrix

================================================================================
PHASE 3: BACKEND API
================================================================================

[ ] 3.1 Core Infrastructure
    [ ] Set up Flask app factory pattern
    [ ] Configure CORS for frontend
    [ ] Create error handlers
    [ ] Create response helpers (success, error formatting)
    [ ] Set up request logging

[ ] 3.2 Guest Endpoints
    [ ] POST /api/guests - Create guest registration
        - Validate all required fields
        - Check for existing email (offer magic link if exists)
        - Store guest in database
        - Queue submission confirmation email
        - Log activity
    [ ] GET /api/guests/<id> - Get guest details
        - Require magic link auth token
        - Return guest profile (exclude sensitive fields)
    [ ] PUT /api/guests/<id> - Update guest profile
        - Require magic link auth token
        - Validate fields
        - Update and log activity

[ ] 3.3 Host Endpoints
    [ ] POST /api/hosts - Create host registration
        - Validate all required fields
        - Check for existing email
        - Store host in database
        - Queue submission confirmation email
        - Log activity
    [ ] GET /api/hosts/<id> - Get host details
        - Require magic link SESSION token (not action token)
        - Return host profile
    [ ] PUT /api/hosts/<id> - Update host profile
        - Require magic link SESSION token
        - Validate fields
        - Update and log activity

[ ] 3.4 Auth Endpoints

    *** THREE TOKEN TYPES - KEEP SEPARATE ***

    Magic Link Auth (for profile editing):
    [ ] POST /api/auth/request-link - Request magic link
        - Accept email addressc
        - Look up user (guest or host)
        - Generate secure token (32+ chars)
        - Store in MagicLink table with 15-minute expiration
        - Queue magic link email
    [ ] POST /api/auth/verify - Verify magic link token
        - Validate token exists and not expired
        - Mark token as used
        - Return user info and SESSION token for profile editing

    Match Action Token (for one-click accept/decline):
    [ ] POST /api/matches/respond - Accept or decline match
        - Extract signed action token from request
        - Verify signature using HMAC + SECRET_KEY
        - Check token not expired
        - Validate match exists and is in 'requested' status
        - Update match status to 'accepted' or 'declined'
        - If accepted: notify ADMIN ONLY (no guest email yet)
        - If declined: notify admin
        - Return confirmation page data
        *** NO SESSION CREATED - just performs action ***

    [ ] Create token signing utilities:
        - generate_action_token(match_id, action, expires_in) -> str
        - verify_action_token(token) -> {match_id, action} or None
        - Use HMAC-SHA256 with SECRET_KEY

[ ] 3.5 Admin Auth
    [ ] POST /api/admin/auth - Admin login
        - Accept password
        - Compare against hashed env variable
        - Return session token
    [ ] Create admin auth middleware
        - Validate admin session token on protected routes

[ ] 3.6 Admin Endpoints (Pilot MVP - Minimal Set)

    Dashboard:
    [ ] GET /api/admin/dashboard - Dashboard stats
        - Total guests, total hosts, total seats
        - Guests placed, pending decisions, confirmed
        - Alerts (unmatched guests, unused capacity, strict kosher unmatched)

    Guest Management:
    [ ] GET /api/admin/guests - List all guests
        - Basic filtering only (match status)
        - Include current match status
    [ ] GET /api/admin/guests/<id> - Guest detail
        - Full profile, match info, no-show flag

    Host Management:
    [ ] GET /api/admin/hosts - List all hosts
        - Include capacity info (seats available vs used)
    [ ] GET /api/admin/hosts/<id> - Host detail
        - Full profile, assigned guests

    Match Management:
    [ ] GET /api/admin/matches - List all matches
        - Filter by status
        - Include guest and host summaries
    [ ] POST /api/admin/matches/generate - Run matching algorithm
        - Clear existing proposed matches
        - Run matching service via adapter
        - Return proposed matches with scores
    [ ] PUT /api/admin/matches/<id> - Edit match
        - Reassign guest to different host (dropdown, not drag-drop)
        - Recalculate "why it's a fit"
    [ ] DELETE /api/admin/matches/<id> - Remove match
        - Only if status is 'proposed'
    [ ] POST /api/admin/matches/<id>/send - Send match request
        - Change status to 'requested'
        - Generate signed action token for accept/decline links
        - Queue match request email to host with action links
        - Log activity
    [ ] POST /api/admin/matches/<id>/finalize - Finalize match
        - Require status is 'accepted'
        - Change status to 'confirmed'
        - Queue confirmation emails to BOTH parties (this is when guest learns)
        - Log activity

    No-Show Management:
    [ ] POST /api/admin/guests/<id>/flag - Flag guest for no-show
        - Set is_flagged = true
        - Increment no_show_count
        - Log activity

[ ] 3.7 No-Show Enforcement Endpoints (signed tokens, no login)

    [ ] POST /api/attendance/confirm - Guest confirms attendance
        - Verify signed token (contains match_id)
        - Update Match.guest_confirmed_at = now()
        - Return confirmation page data
        *** Confirmation stored on Match, not Guest ***

    [ ] GET /api/noshow/report - Get report form (for host)
        - Verify signed token (contains host_id)
        - Server looks up all confirmed matches for that host
        - Returns list of guests (id, name) that host CAN report on
        *** Host cannot report arbitrary guests - server controls the list ***

    [ ] POST /api/noshow/report - Host submits no-show report
        - Verify signed token (contains host_id)
        - Accept list of match_ids (NOT guest_ids) marked as no-show
        - Server validates each match_id belongs to this host
        - Update Match.guest_no_show = true, Match.no_show_reported_at = now()
        - Increment Guest.no_show_count for each
        - Queue admin notification
        - Return confirmation
        
        *** SECURITY: Token identifies host, server derives allowed matches ***
        *** Client only submits checkboxes for matches server provided ***

    [ ] Create signed tokens for:
        - attendance_confirm_token(match_id, expires)
        - noshow_report_token(host_id, expires)

    *** DEFERRED TO POST-PILOT ***
    - Activity log with filters/pagination
    - Email queue view and resend
    - Settings/pause toggle (use env var)
    - Advanced filtering and sorting
    - Batch send operations

================================================================================
PHASE 4: MATCHING ENGINE (ISOLATED & PLUG-AND-PLAY)
================================================================================

*** CRITICAL ARCHITECTURE REQUIREMENT ***
The matching engine MUST be completely isolated from the rest of the application.
It should be a standalone module with a clear interface that can be:
  - Swapped out for a different algorithm
  - Upgraded to ML-based matching in the future
  - Tested independently
  - Replaced without touching any other code

The matching engine should:
  - Live in its own directory: /backend/app/matching/
  - Have NO dependencies on Flask, routes, or database sessions
  - Accept plain Python objects/dicts as input
  - Return plain Python objects/dicts as output
  - Be callable from anywhere (API, CLI, tests, scripts)
******************************************

[ ] 4.1 Define Matching Interface
    [ ] Create abstract base class / protocol:
        
        class MatchingEngineInterface:
            def generate_matches(
                self,
                guests: List[GuestData],
                hosts: List[HostData],
                config: MatchingConfig
            ) -> MatchingResult
        
    [ ] Define input data structures (plain dataclasses, NO ORM models):
        - GuestData: all guest fields needed for matching
        - HostData: all host fields needed for matching
        - MatchingConfig: weights, thresholds, options
    [ ] Define output data structures:
        - MatchingResult: list of ProposedMatch
        - ProposedMatch: guest_id, host_id, score, alternatives, why_fit

[ ] 4.2 Create Matching Engine Directory Structure
    [ ] /backend/app/matching/
        - __init__.py (exports the interface and default engine)
        - interface.py (abstract interface definition)
        - data_types.py (GuestData, HostData, MatchingConfig, etc.)
        - engine.py (default implementation)
        - scoring.py (scoring functions)
        - eligibility.py (eligibility checks)
        - distance.py (neighborhood distance matrix)
        - explainer.py ("why it's a fit" generator)
        - tests/ (unit tests for matching logic)

[ ] 4.3 Implement Eligibility Checks (eligibility.py)
    [ ] is_eligible(guest: GuestData, host: HostData) -> bool
    [ ] Check seat capacity >= party size
    [ ] Check kosher compatibility matrix
    [ ] Check language overlap (at least one)
    [ ] Check travel preference vs neighborhood distance

[ ] 4.4 Implement Neighborhood Distance Matrix (distance.py)
    [ ] Create Manhattan neighborhood distance data
    [ ] get_travel_time(neighborhood_a, neighborhood_b) -> int
    [ ] Map travel times between neighborhoods (coarse buckets):
        - Same neighborhood: ~10 min
        - Adjacent: ~20 min
        - Moderate: ~35 min
        - Far: ~50+ min
    [ ] is_within_travel_preference(guest, host) -> bool
        - guest.max_travel_time options: 15, 30, 45, 60
        - Return true if estimated travel <= preference

[ ] 4.5 Implement Scoring Functions (scoring.py)
    [ ] calculate_distance_score(guest, host) -> float
    [ ] calculate_vibe_score(guest, host) -> float
        - Euclidean distance on 3 sliders, normalized
    [ ] calculate_contribution_score(guest, host) -> float
    [ ] calculate_capacity_score(host, current_assignments) -> float
    [ ] calculate_total_score(guest, host, config) -> float
        - Weighted combination of all scores

[ ] 4.6 Implement Assignment Algorithm (engine.py)
    [ ] Default greedy assignment implementation
    [ ] Track remaining capacity per host
    [ ] Generate top N alternatives per guest
    [ ] Respect config options (weights, thresholds)
    
    *** CRITICAL CAPACITY INVARIANTS ***
    The algorithm MUST guarantee:
    [ ] No guest is ever assigned to multiple hosts
    [ ] No host capacity ever goes negative
    [ ] party_size is correctly subtracted from capacity
    [ ] Unplaceable guests are returned as "unmatched" list
    [ ] Add assertions/checks for these invariants

[ ] 4.7 Implement "Why It's a Fit" Generator (explainer.py)
    [ ] generate_explanation(guest, host, scores) -> str
    [ ] Template-based explanation generator
    [ ] Include factors:
        - Shared language(s)
        - Kosher compatibility
        - Vibe similarity (which dimensions match)
        - Neighborhood proximity
    [ ] Output 1-2 friendly sentences

[ ] 4.8 Create Adapter Layer (in /backend/app/services/)
    [ ] Create matching_adapter.py that:
        - Converts ORM Guest models -> GuestData
        - Converts ORM Host models -> HostData
        - Calls the matching engine
        - Converts MatchingResult -> creates Match ORM records
    [ ] This is the ONLY place where ORM and matching engine meet

[ ] 4.9 Unit Tests for Matching Engine
    [ ] Test eligibility checks in isolation
    [ ] Test scoring functions in isolation
    [ ] Test distance matrix
    [ ] Test full matching with mock data
    [ ] Test explainer output
    [ ] All tests should work WITHOUT database or Flask

================================================================================
PHASE 5: FRONTEND - SHARED COMPONENTS
================================================================================

*** STYLING CONVENTION: CSS MODULES ***
- Each component has a co-located .module.css file
- NO inline styles anywhere
- Use CSS variables from styles/variables.css for colors, fonts, spacing
- Class names use camelCase in modules
- Import styles as: import styles from './Component.module.css'
******************************************

[ ] 5.1 Layout Components
    [ ] Create main layout wrapper
        - Layout.tsx + Layout.module.css
    [ ] Create header component (with JLC branding)
        - Header.tsx + Header.module.css
    [ ] Create footer component
        - Footer.tsx + Footer.module.css
    [ ] Create mobile navigation
        - MobileNav.tsx + MobileNav.module.css

[ ] 5.2 Form Components (each with .module.css)
    [ ] TextInput - text input with label and validation
    [ ] PhoneInput - phone input with formatting
    [ ] EmailInput - email input with validation
    [ ] Select - styled dropdown
    [ ] MultiSelect - for languages
    [ ] RadioGroup - for kosher, contribution
    [ ] VibeSlider - 1-5 slider with labels
    [ ] Checkbox - for policy acknowledgement
    [ ] Textarea - for notes
    [ ] FormError - error display component

[ ] 5.3 UI Components (each with .module.css)
    [ ] Button - primary, secondary, ghost variants
    [ ] Card - content container
    [ ] Alert - notification/alert component
    [ ] Spinner - loading indicator
    [ ] Modal - dialog overlay
    [ ] Badge - tag/badge component
    [ ] Progress - progress indicator

[ ] 5.4 API Client
    [ ] Create fetch wrapper with error handling
    [ ] Create typed API functions for each endpoint
    [ ] Handle auth token storage/retrieval

================================================================================
PHASE 6: FRONTEND - PUBLIC PAGES
================================================================================

[ ] 6.1 Landing Page
    [ ] Hero section with warm welcome
    [ ] Brief explanation of ShabbatLink
    [ ] Two clear CTAs: "I want to attend" / "I want to host"
    [ ] JLC branding and trust signals

[ ] 6.2 Guest Registration Form
    [ ] Multi-step form or single scrolling form
    [ ] All required fields from PRD Section 8.1
    [ ] Real-time validation
    [ ] No-show policy with clear acknowledgement
    [ ] Submission confirmation screen
    [ ] "Already registered?" link to magic link flow

[ ] 6.3 Host Registration Form
    [ ] All required fields from PRD Section 8.2
    [ ] Address field (with privacy note)
    [ ] Tagline field (optional)
    [ ] No-show policy acknowledgement
    [ ] Submission confirmation screen

[ ] 6.4 Magic Link Request Page
    [ ] Email input
    [ ] "Send me a login link" button
    [ ] Success message with instructions
    [ ] Check spam folder note

[ ] 6.5 Magic Link Verify Page
    [ ] Token verification on load
    [ ] Loading state
    [ ] Success: redirect to profile edit
    [ ] Error: expired/invalid message with retry option

[ ] 6.6 Profile Edit Page (Guest)
    [ ] Pre-filled form with existing data
    [ ] Same validation as registration
    [ ] Save changes button
    [ ] Success confirmation

[ ] 6.7 Profile Edit Page (Host)
    [ ] Pre-filled form with existing data
    [ ] Save changes button
    [ ] View pending match requests (if any)

[ ] 6.8 Host Match Response Page
    [ ] Accessed via signed action token link in match request email
    [ ] Extract token from URL, pass to API
    [ ] Show guest summary (no phone/address)
    [ ] Show "why it's a fit" explanation
    [ ] Accept / Decline buttons
        - On click: POST /api/matches/respond with signed token
        - Token contains match_id + action (accept/decline)
    [ ] Confirmation screen after response
    *** NO SESSION OR MAGIC LINK REQUIRED ***
    *** Page works purely with signed action token from email ***

[ ] 6.9 Match Confirmation Page (Guest)
    [ ] Show host details (now including address and phone)
    [ ] Show dinner expectations
    [ ] Day-of confirmation button (when applicable)

[ ] 6.10 Match Confirmation Page (Host)
    [ ] Show confirmed guest list with phones
    [ ] Show dinner date reminder

[ ] 6.11 Guest Attendance Confirmation Page
    [ ] Accessed via signed token link in day-of reminder email
    [ ] Shows dinner details
    [ ] "Yes, I'm attending" button
    [ ] Confirmation success message
    [ ] No login required (uses signed token)

[ ] 6.12 Host No-Show Report Page
    [ ] Accessed via link in post-event email
    [ ] Lists confirmed guests for that host
    [ ] Checkbox to flag each guest as no-show
    [ ] Submit button
    [ ] No login required (uses signed token)

================================================================================
PHASE 7: FRONTEND - ADMIN PANEL
================================================================================

[ ] 7.1 Admin Login Page
    [ ] Password input
    [ ] Login button
    [ ] Error handling for wrong password
    [ ] Redirect to dashboard on success

[ ] 7.2 Admin Layout
    [ ] Sidebar navigation (Pilot MVP):
        - Dashboard
        - Guests
        - Hosts
        - Matches
    [ ] Header with logout button
    *** Emails, Activity Log, Settings deferred to post-pilot ***

[ ] 7.3 Admin Dashboard
    [ ] Stats cards:
        - Total guests
        - Total hosts
        - Total seats
        - Placed guests
        - Pending decisions
        - Confirmed matches
    [ ] Alerts section:
        - Unmatched guests
        - Strict kosher unmatched
        - Hosts with unused capacity
    [ ] Quick actions

[ ] 7.4 Admin Guests View
    [ ] Searchable, filterable table
    [ ] Columns: name, neighborhood, party size, kosher, status
    [ ] Click to view detail
    [ ] Guest detail modal/page:
        - Full profile info
        - Match history
        - No-show flags
        - Admin notes

[ ] 7.5 Admin Hosts View
    [ ] Searchable, filterable table
    [ ] Columns: name, neighborhood, seats, kosher, capacity used
    [ ] Click to view detail
    [ ] Host detail modal/page:
        - Full profile info
        - Assigned guests
        - Private notes

[ ] 7.6 Admin Matching View
    [ ] "Generate Matches" button
    [ ] Matches grouped by host with capacity indicator
    [ ] For each match:
        - Guest summary (name, party size, neighborhood)
        - Match score
        - "Why it's a fit"
        - Status badge (proposed/requested/accepted/declined/confirmed)
    [ ] Reassign via DROPDOWN (not drag-and-drop - that's v2)
        - Select shows eligible hosts with remaining capacity
        - "Unassign" option to remove match
    [ ] Actions per match:
        - Send request (if proposed)
        - Finalize (if accepted)
        - Remove (if proposed)
    [ ] Status filter tabs: All / Proposed / Requested / Accepted / Confirmed

*** DEFERRED TO POST-PILOT ***
[ ] 7.7 Admin Emails View (nice to have, not MVP)
[ ] 7.8 Admin Activity Log (nice to have, not MVP)
[ ] 7.9 Admin Settings (use env var for pause, not UI)

================================================================================
PHASE 8: EMAIL TEMPLATES (SIMULATED FOR PILOT)
================================================================================

[ ] 8.1 Create Email Template System
    [ ] Base HTML template with JLC branding (teal/bronze colors)
    [ ] Simple template variables: {{name}}, {{link}}, etc.
    [ ] All emails logged to database, displayed in admin (simulated send)

[ ] 8.2 Email Templates (English only for pilot)
    [ ] Guest submission confirmation
        - "Thanks for registering! We'll be in touch when we find a match."
    [ ] Host submission confirmation
        - "Thanks for offering to host! We'll send you match requests soon."
    [ ] Magic link email (for profile editing)
        - "Click here to edit your profile" + 15-min expiry note
    [ ] Match request to host
        - Guest summary (name, party size, neighborhood, vibe)
        - "Why it's a fit" explanation
        - Accept link (signed token)
        - Decline link (signed token)
        *** CRITICAL: Links use signed action tokens, not login ***
    [ ] Match confirmed - guest notification
        - "You're confirmed for Shabbat dinner!"
        - Host name, address, phone
        - Dinner expectations
        *** ONLY sent when admin finalizes, not when host accepts ***
    [ ] Match confirmed - host notification
        - "Your guest is confirmed!"
        - Guest name, phone, party size
    [ ] Match declined - admin notification (internal)
        - Simple alert that host declined
    [ ] Day-of reminder to guest
        - "Shabbat Shalom! Please confirm you're attending"
        - Confirm attendance link (signed token)
    [ ] Day-of summary to host
        - Guest list with names and party sizes
    [ ] Post-event no-show report request to host
        - "Did all guests attend? Report any no-shows"
        - Link to report form

*** MULTI-LANGUAGE DEFERRED TO POST-PILOT ***
For pilot, use English only. Optionally include brief Spanish line at bottom.
Full i18n template system is post-pilot work.

================================================================================
PHASE 9: TESTING (PILOT SCOPE)
================================================================================

*** FOCUS ON UNIT TESTS FOR CORE LOGIC ***
*** E2E TEST SUITE IS POST-PILOT - TOO MUCH SETUP FOR MVP ***

[ ] 9.1 Matching Engine Unit Tests (CRITICAL)
    [ ] Test eligibility checks:
        - Seat capacity vs party size
        - Kosher compatibility matrix (all 9 combinations)
        - Language overlap
        - Travel time constraints
    [ ] Test scoring functions:
        - Distance scoring
        - Vibe similarity scoring
        - Contribution alignment
    [ ] Test assignment algorithm:
        - No guest assigned twice
        - No host capacity goes negative
        - Handles party_size > 1 correctly
    [ ] Test "why it's a fit" generator output

[ ] 9.2 Token Signing Unit Tests
    [ ] Test action token generation
    [ ] Test action token verification
    [ ] Test expired token rejection
    [ ] Test tampered token rejection

[ ] 9.3 Manual QA (Pre-Launch)
    [ ] Test guest registration on mobile
    [ ] Test host registration on mobile
    [ ] Test match accept/decline links work without login
    [ ] Test profile edit via magic link
    [ ] Test admin matching flow end-to-end
    [ ] Verify emails appear in simulated queue

*** DEFERRED TO POST-PILOT ***
- Automated E2E test suite
- Frontend component tests
- API integration tests
- Full regression suite

================================================================================
PHASE 10: DEPLOYMENT
================================================================================

[ ] 10.1 Render Setup - Backend
    [ ] Create Render account (if needed)
    [ ] Create PostgreSQL database
    [ ] Create Web Service for Flask API
    [ ] Configure environment variables:
        - DATABASE_URL
        - ADMIN_PASSWORD
        - SECRET_KEY
        - FRONTEND_URL
    [ ] Set up build command: pip install -r requirements.txt
    [ ] Set up start command: gunicorn run:app

[ ] 10.2 Render Setup - Frontend
    [ ] Create Static Site or Web Service for Next.js
    [ ] Configure environment variables:
        - NEXT_PUBLIC_API_URL
    [ ] Set up build command: npm run build
    [ ] Configure redirects for SPA routing

[ ] 10.3 Domain & SSL
    [ ] Configure custom domain (if applicable)
    [ ] Verify SSL certificates

[ ] 10.4 Pre-Launch Checklist
    [ ] Run database migrations on production
    [ ] Set strong admin password
    [ ] Test all flows on production
    [ ] Verify CORS settings
    [ ] Check error logging

[ ] 10.5 Launch
    [ ] Share guest registration link
    [ ] Share host registration link
    [ ] Monitor for errors
    [ ] Be ready for support

================================================================================
POST-PILOT TASKS (Future)
================================================================================

[ ] Integrate real email service (SendGrid or Resend)
[ ] Add actual geolocation for distance calculation
[ ] Build no-show reporting UI for hosts
[ ] Add post-event satisfaction survey
[ ] Build historical data and analytics dashboard
[ ] Consider recurring event scheduling

================================================================================
NOTES
================================================================================

Priority Order:
1. Phase 1-2: Foundation (must complete first)
2. Phase 3: Backend API (core functionality)
3. Phase 4: Matching engine (core value)
4. Phase 5-6: Public-facing frontend (user-facing)
5. Phase 7: Admin panel (staff-facing)
6. Phase 8: Email templates (communication)
7. Phase 9: Testing (quality)
8. Phase 10: Deployment (launch)

Estimated Timeline:
- Phase 1-2: 1-2 days
- Phase 3-4: 3-4 days
- Phase 5-6: 3-4 days
- Phase 7: 2-3 days
- Phase 8: 1 day
- Phase 9: 1-2 days
- Phase 10: 1 day

Total: ~2-3 weeks for MVP

================================================================================
ARCHITECTURE DECISIONS
================================================================================

*** MATCHING ENGINE ISOLATION (CRITICAL) ***

The matching engine is intentionally isolated as a plug-and-play module.

Why:
- Enables swapping to ML-based matching without code changes elsewhere
- Allows independent testing without database/Flask dependencies
- Makes algorithm improvements safe and easy
- Supports running matching from CLI/scripts for debugging

Structure:
    /backend/app/matching/       <-- ISOLATED MODULE (no Flask, no ORM)
        interface.py             <-- Abstract interface
        data_types.py            <-- Plain Python dataclasses
        engine.py                <-- Default implementation
        scoring.py, etc.

    /backend/app/services/
        matching_adapter.py      <-- ADAPTER (converts ORM <-> plain data)

Data Flow:
    1. API route receives request to generate matches
    2. Adapter queries database, converts ORM models -> plain GuestData/HostData
    3. Adapter calls matching_engine.generate_matches(guests, hosts, config)
    4. Matching engine returns plain MatchingResult (no ORM knowledge)
    5. Adapter converts MatchingResult -> creates/updates Match ORM records
    6. API route returns response

To swap algorithms:
    1. Create new engine implementing MatchingEngineInterface
    2. Change one line in adapter to use new engine
    3. Done. No other code changes needed.

================================================================================
KEY ARCHITECTURAL DECISIONS
================================================================================

*** THREE TOKEN TYPES - NEVER CONFUSE THEM ***

1. Admin Session Token
   - Created on password login
   - Stored in browser (cookie or localStorage)
   - Required for all /api/admin/* endpoints
   - Long-lived (hours/days)

2. Magic Link Token (profile editing)
   - One-time use, stored in MagicLink table
   - Sent via email to returning users
   - 15-minute expiration
   - On verify: creates SESSION for profile editing
   - ONLY for profile edit, NOT for match responses

3. Signed Action Token (one-click actions)
   - NOT stored in database - stateless
   - Signed with HMAC-SHA256 using SECRET_KEY
   - Encodes: action + target_id + expiration
   - Used for: match accept/decline, attendance confirm, no-show report
   - NO SESSION created - just performs action
   - Enables frictionless one-click UX from email

*** MATCH STATUS FLOW (5 STATES) ***

proposed → requested → accepted → confirmed
                   ↘ declined

- proposed: Admin-only, algorithm output
- requested: Sent to host, awaiting response
- accepted: Host said yes, awaiting admin finalization
- declined: Host said no
- confirmed: Admin finalized, details released to both parties

Key rule: Guest ONLY learns about match when admin finalizes (confirmed).
Host accept does NOT trigger guest notification.

*** NOTIFICATION FLOW ***

Host accepts match:
  → Match status: accepted
  → Admin notified (so they can finalize)
  → Guest NOT notified yet

Admin finalizes match:
  → Match status: confirmed
  → Guest receives confirmation with host details
  → Host receives confirmation with guest details

This prevents premature guest excitement if admin needs to review/adjust.

*** DATA MODEL: PROFILE vs EVENT ***

For pilot, Guest/Host tables combine:
  - Profile data (name, email, phone, neighborhood, languages, kosher, vibe)
  - Event data (party_size, seats_available)

Code should treat these as conceptually separate.
Future: Split into GuestProfile + GuestEventRegistration tables.
